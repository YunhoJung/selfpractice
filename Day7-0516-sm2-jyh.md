# Day7

## Stashin과 Cleaning

### stashing
- 작업을 하던 중 다른 요청이 들어와 완료하지 않은 프로젝트를 커밋하지 않고 나중에 다시 돌아와서 다시 작업을 하고 싶을 때.

```
$ git stash
```

##### 예제
1. 파일 두 개를 수정하고 그 중 하나는 staging area에 추가한다. 그리고 git status 명령을 실행하면 
2. 브랜치를 변경한다. 아직 작업 중인 파일은 커밋할 게 아니라서 모두 stash한다. 'git stash'나 'git stash save'를 실행하면 스택에 새로운 stash가 만들어진다.
3. 아무 브랜치나 골라서 쉽게 바꿀 수 있고, 수정하던 것을 스택에 저장했다. 'git stash list'를 사용하여 저장한 stash를 확인한다.
4. 'git stash apply'를 사용하여 stash를 다시 적용할 수 있다. 예를 들어 'git stash apply [stash파일명]'처럼 이름을 입력하면 골라서 적용할 수 있다. 이름이 없으면 git은 가장 최근의 stash를 적용한다. (복원할 때의 워킹 디렉토리는 stash 할 때의 그 브랜치)
5. git은 stash를 적용할 때 staged 상태였던 파일을 자동으로 다시 staged 상태로 만들어 주지 않는다. 그래서 'git stash apply'를 실행할 때 뒤에 --index 옵션을 주어 staged 상태까지 적용한다. 그래야 원래 작업하던 상태로 돌아올 수 있다.
6. apply 옵션은 단순히 stash를 적용하는 것 뿐이다. stash는 여전히 스택에 남아 있기 때문에 'git stash drop [stash파일명]' 명령을 사용하여 해당 stash를 제거한다. ('git stash pop [stash파일명]'은 stash를 적용하고 나서 바로 스택에서 제거해준다.

- $'--keep-index' : stash save 명령과 같이 쓰이는 명령어로 이미 staging area에 들어 있는 파일은 stash하지 않는다.

> 많은 파일을 변경했지만 몇 몇 파일만 커밋하고 나머지 파일은 나중에 처리하고 싶을 때 유용하다.

- 추적하지 않는 파일과 추적 중인 파일을 같이 stash 하는 일도 꽤 빈번하다. 기본적으로 'git stash'는 추적 중인 파일만 저장한다. 추적 중이지 않은 파일을 같이 저장하려면 stash 명령을 사용할 때 '--include-untracked'나 '-u'옵션을 붙여준다.

```
$ git stash -u
```
- '--patch' 옵션을 붙이면 git은 수정된 모든 사항을 저장하지 않는다. 대신 대화형 프롬프트가 뜨며 변경된 데이터 중 저장할 것과 저장하지 않을 것을 지정할 수 있다.

- stash에 저장하면 한동안 그대로 유지한 채로 그 브랜치에서 계속 새로운 일을 한다. 그러면 이제 저장한 stash를 적용하는 것이 문제가 된다. 수정한 파일에 stash를 적용하면 충돌이 일어날 수도 있고 그러면 또 충돌을 해결해야 한다. 'git stash branch' 명령을 실행하면 stash 할 당시의 커밋을 checkout한 후 새로운 브랜치를 만들고 여기에 적용한다. 이 모든 것이 성공하면 stash를 삭제한다.

```
$ git stash branch [브랜치명]
```

> 이 명령은 브랜치를 새로 만들고 stash를 복원해주는 매우 편리한 도구이다.

### cleaning

- 작업하고 있던 파일을 stash 하지 않고 단순히 그 파일들을 치워버리고 싶을 때.

```
$ git clean
```

> 워킹 디렉토리 안의 추적하고 있지 않은 모든 파일이 지워지기 때문에 신중히 사용해야 한다.

- 먼저 모든 파일을 stash하고 지워버리기.

```
$ git stash -all
```

- 워킹 디렉토리의 불필요한 파일들을 전부 지우려면

```
$ git clean'
```

- 추적 중이지 않은 모든 정보를 워킹 디렉토리에서 지우고 싶다면(하위 디렉토리까지 모두)

```
$ git clean -f -d
```

> '-f'옵션은 강제(force)의 의미

*이 명령을 실행했을 때 어떤 일이 일어날지 미리 보고 싶다면 '-n'옵션 사용한다. 이 옵션은 가상으로 실행해보고 어떤 파일들이 지워질지 알려달라는 뜻이다. 대화형은 '-i'옵션.*

- 'git clean' 명령은 추적 중이지 않은 파일만 지우는게 기본 동작이다. '.gitignore'에 명시했거나 무시되는 파일은 지우지 않는다. 무시된 파일까지 함께 지우려면 '-x'옵션이 필요하다. 그래서 .o 파일 같은 빌드 파일까지도 지울 수 있다.

## Git 도구 - 검색

### grep
- git의 'grep' 명령을 이용하면 커밋 트리의 내용이나 워킹 디렉토리의 내용을 문자열이나 정규표현식을 이용해 쉽게 찾을 수 있다.

> 기본적으로 대상을 지정하지 않으면 워킹 디렉토리의 파일에서 찾는다. 명령을 실행할 때 '-n'옵션을 추가하면 찾을 문자열이 위치한 라인 번호도 같이 출력한다.

```
$ git grep -n [문자열 또는 정규표현식]
```
- 어떤 파일에서 몇 개나 찾았는지만 알고 싶다면 '--count' 옵션을 이용한다.

```
$ git grep --count [문자열 또는 정규표현식]
```

- 매칭되는 라인이 있는 함수나 메서드를 찾고 싶다면 '-p' 옵션을 준다.

```
$ git grep -p [함수나 매서드]
```
> *.c : date.c인 모든 파일

- '--and' 옵션을 이용해서 여러 단어가 한 라인에 동시에 나타나는 줄 찾기 같은 복잡한 조합으로 검색할 수 있다.

- '--break'와 '--heading' 옵션을 붙여 더 읽기 쉬운 헝태로 잘라서 출력할 수도 있다.

*'git grep'명령은 'grep'이나 'ack'같은 일반적인 검색 도구보다 몇가지 좋은 점이 있다. 매우 빠르며, 워킹 디렉토리만이 아니라 git 히스토리 내의 어떠한 정보라도 찾아낼 수 있다.

### git 로그 검색
- 어떤 변수가 어디에 있는지를 찾아보는게 아니라, 히스토리에서 언제 추가되거나 변경됐는지 찾아볼 수도 있다. 'git log' 명령을 이용하면 diff 내용도 검색하여 어떤 커밋에서 찾고자 하는 내용을 추가했는지 찾을 수 있다.

```
$ git log -s[문자열] <!----oneline-->
```

> '-s' 옵션을 이용해 해당 문자열이 추가된 커밋과 없어진 커밋만 검색할 수 있다. 더 세세한 조건을 걸어 찾고 싶다면 로그를 검색할 때 '-G' 옵션으로 정규표현식을 써서 검색하면 된다.

- *라인 로그 검색* : 라인 히스토리 검색으로 'git log -L'옵션을 붙이면 어떤 함수나 한 라인의 히스토리를 볼 수 있다.

```
$ git log -L:[함수명]:[파일명]
```
> 이 명령을 실행하면 함수의 시작과 끝을 인식해서 함수에서 일어난 모든 히스토리를 함수가 처음 만들어진 때부터 Patch를 나열하여 보여준다.

*git이 함수의 처음과 끝을 인식하지 못할 때는 정규표현식으로 인식하게 할 수도 있다. 한 라인의 히스토리만 검색할 수도 있고 여러 라인에 걸친 히스토리를 검색할 수도 있다.*

## Git 도구 - 히스토리 단장하기

- git으로 하던 일을 stash 명령으로 미룰 수 있고, 이미 커밋해서 결정한 내용을 수정할 수 있다. 커밋들의 순서도 변경할 수 있고, 커밋 메시지와 커밋한 파일도 변경할 수 있다. 여러 개의 커밋을 하나로 합치거나 반대로 커밋 하나를 여러 개로 분리할 수도 있다. 아니면 커밋 전체를 삭제할 수 있다. *이 모든 것은 다른 사람과 코드를 공유하기 전에 해야한다.*

### 사람들과 코드를 공유하기 전에 커밋 히스트리를 예쁘게 단장하는 방법
1. 커밋 메시지를 수정하는 것

```
$ git commit --amend
```

> 현 staging area의 내용을 이용해서 수정한다.

2. 커밋 메시지를 여러 개 수정하기

```
$ git rebase -i(대화형 모드 옵션) HEAD-n(이 범위에 있는 모든 커밋)
```

> 이미 중앙서버에 push 한 커밋은 절대 고치지 말아야 한다.

*'git log'와 역순. 순서대로 적용하는 것이기 때문에 제일 위에 있는 것이 최신이 아니라 가장 오래된 것이다.*

3. 커밋 순서 바꾸기

대화형 rebase 도구로 커밋 전체를 삭제하거나 조정할 수 있다.

4. 커밋 합치기

대화형 rebase 명령을 이용하여 여러 개의 커밋을 하나의 커밋으로 만들어 버릴 수 있다.

```
'pick'이나 'edit'말고 'squash'를 입력하면 git은 해당 커밋과 바로 이전 커밋을 합칠 것이고 커밋 메시지도 merge한다.
```
5. 커밋 분리하기

*기존의 커밋을 해제하고(혹은 되돌려 놓고) stage를 여러 개로 분리하고 나서 그것을 원하는 횟수만큼 다시 커밋하는 것*

```
$ git reset HEAD^
$ git add README
$ git commit -m 'updated README formatting'
$ git add lib/simplegit.rb
$ git commit -m 'added blame'
$ git rebase --continue

```
나머지 커밋도 처리되면 히스토리는 아래와 같다.

```
$ git log -4 --pretty=format:"%h %s"
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
```
> rebase 하면 목록에 있는 모든 커밋의 SHA-1 값을 변경된다. 절대로 이미 서버에 push 한 커밋을 수정하면 안 된다.

### filter-branch
- 수정해야 하는 커밋이 너무 많아서 rebase 스크립트로 수정하기 어려울 것 같을 때 사용한다.

> 이 또한 역시 수젇하려는 커밋이 이미 공개돼서 다른 사람과 함께 공유하는 중이라면 사용하지 말아야 한다.

- 모든 커밋에서 파일 제거하기

```
$ git filter-branch --tree-filter 'rm -f passwors.txt' HEAD
```
'--tree-filter' 옵션은 프로젝트를 checkout한 후에 각 커밋에 명시한 명령을 실행시키고 그 결과를 다시 커밋한다. 이 경우에는 각 스냅샷에 [passwords.txt] 파일이 있으면 그 파일을 삭제한다. 이런 작업은 테스팅 브랜치에서 실험하고 나서 master 브랜치에 적용하는 게 좋다. 'filter-branch' 명령에 '--all'옵션을 추가하면 모든 브랜치에 적용할 수 있다.

- 하위 디렉토리를 루트 디렉토리로 만들기
*ex) 모든 커밋에 대해 'trunk' 디렉토리를 프로젝트 루트 디렉토리로 만들 때

```
$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref 'refs/heads/master' was rewritten
```
> git은 입력한 디렉토리와 관련이 없는 커밋을 자동으로 삭제한다.

- 'filter-branch'명령의 '--commit-filter'옵션을 사용하여 해당 커밋만 골라서 이메일 주소를 수정할 수 있댜.

```
$ git filter-branch --commit-filter '
        if [ "$GIT_AUTHOR_EMAIL" = "schacon@localhost" ];
        then
                GIT_AUTHOR_NAME="Scott Chacon";
                GIT_AUTHOR_EMAIL="schacon@example.com";
                git commit-tree "$@";
        else
                git commit-tree "$@";
        fi' HEAD
```






